# 경계 간 매핑하기

매핑에 대해 흔히 하는 논의
- 매핑에 찬성입장: 매핑하지 않으면 두 계층이 강하게 결합된다.
- 매핑에 반대입장: 핵심 액션에 비해서 준비(보일러플레이트)가 너무 과하다.

## '매핑하기 않기' 전략
- AccountController - SendMoneyUseCase - AccountPersistenceAdapter 간 Account을 같이 사용
- 문제점
    - 웹계층, 영속성 계층에서 특별한 요구사항이 있을 수 있다.
    - 특수 요구사항에 관심이 없더라도 이런 요구사항을 다뤄야 한다. => 단일책임원칙 위반
- 필요한 경우
    - 간단한 CRUD유스케이스의 경우
    - JSON, ORM 애너테이션: 크게 영향을 주지 않기 때문이다.
- 어떤 매핑 전략을 사용했더라도 나중에 언제든 바꿀 수 있다.

## '양방향' 매핑 전략
- 각 계층이 전용 모델을 가진 매핑 전략
- AccountController(웹모델) - SendMoneyUseCase(Account) - AccountPersistenceAdapter(영속성 모델)
- 각 계층이 전용 모델을 가지고 있기 때문에 한 계층이 변하더라도 다른 계층에 영향이 없다.
- 장점
    - 관심사가 오염되지않은 깨끗한 모델을 가진다. -> 단일책임원칙 만족
    - 간단하다. 다른 계층의 모델로 매핑만 해주면 계층 내부에서는 내부 모델만 알면 된다.
- 단점
    - 너무 많은 보일러플레이트 코드가 생긴다.
    - 도메인 모델이 계층 경계를 넘어 통신하는데 사용되어 외부 변화에 취약해진다.
- 많은 프로젝트에서 이 매핑을 철칙처럼 사용하는데 어떤 매핑 전략도 철칙처럼 여겨져서는 안된다.

## '완전' 매핑 전략
- AccountController(웹모델) - SendMoneyUseCase(SendMoneyCommand) - SendMoneyService(Account) - UpdateAccountStatePort(UpdateAccountStateCommand) - AccountPersistenceAdapter(영속성 모델)
- 각 연산마다 별도의 입출력모델을 사용
- 매핑에 더 많은 코드가 필요하다.
- 대신 하나의 요구사항에만 집중할 수 있어 구현/유지보수가 쉽다.
- 이 전략은 인커밍 어댑터 - 애플리케이션 사이에서 유스케이스의 경계를 명확히 할 때 빛을 발한다.
- 애플리케이션 - 영속성 사이에서는 매핑 오버헤드때문에 비추천
- 입력에만 이 전략을 사용하고 반환은 도메인 모델을 그대로 사용하는 등 섞어 쓰는 것도 좋다.

## '단방향' 매핑 전략
- 각 계층의 모델이 하나의 인터페이스를 구현하여 캡슐화하는 전략
- 바깥 계층이 상태 인터페이스를 사용할지 전용모델로 매핑을 할지 결정할 수 있다.
- DDD의 factory와 잘 어울린다.
- 한 계층이 다른 계층으로부터 객체를 받으면 해당 계층에서 이용할 수 있도록 다른 무언가로 매핑하는 것.
- 계층 간의 모델이 비슷할 때 가장 효과적

## 언제 어떤 매핑 전략을 사용할 것인가?
- 그때그때 다르다
- 팀 내에서 합의할 수 있는 가이드라인을 정해둬야한다. (무엇이 우선순위인지, 차선은 무엇인지? 등)

## 생각해볼 부분
- 각 계층이 전용모델을 가지고 있고 한 계층이 변화하더라도 정말 다른 계층에 변화가 없나? 단순 내부로직의 변화는 그럴 수 있지만 대부분의 변화는 입출력의 변화도 있었다. 완벽한 설계가 기반이 될때만 그게 가능하다.

